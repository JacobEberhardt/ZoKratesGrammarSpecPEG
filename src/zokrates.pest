/** 
* ZoKrates Grammar
* Author: Jacob Eberhardt
*/

// TODO: 
// exclude language keywords as identifiers: DONE
// Ignore linebreak after \
// Doc: associativity and precedence table for operators

file = { SOI ~ NEWLINE* ~ import_directive* ~ NEWLINE* ~ function_definition* ~ EOI }
import_directive = {"import" ~ "\"" ~ (!"\"" ~ ANY)* ~ "\"" ~ ("as" ~ identifier)? ~ NEWLINE+}
function_definition = {"def" ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ "->" ~ "(" ~ (type_name ~ ("," ~ type_name)*)? ~ ")" ~ ":" ~ NEWLINE* ~ statement* }

parameter_list = {parameter ~ ("," ~ parameter)*}
parameter = {"private"? ~ type_name ~ identifier}
type_name = @{"field" ~ ("[" ~ WHITESPACE* ~ expression ~ WHITESPACE* ~ "]")* | "bool" ~ ("[" ~ WHITESPACE* ~ "]")* }

// Statements 
statement = { (return_statement // does not require subsequent newline
              | (iteration_statement
                | multi_assignment_statement
                | definition_statement
                | assignment_statement
                | expression_statement 
                ) ~ NEWLINE 
            ) ~ NEWLINE* }

iteration_statement = { "for" ~ type_name ~ identifier ~ "in" ~ constant ~ ".." ~ constant ~ "do" ~ NEWLINE* ~ statement* ~ "endfor"}
return_statement = { "return" ~ expression_list}
multi_assignment_statement = { assignee_list ~ "=" ~ identifier ~ "(" ~ expression_list? ~ ")"} // This is very specific with regards to parsing. However, I think more generality is not needed here.
definition_statement = {type_name ~ identifier ~ "=" ~ expression}
assignment_statement = {identifier ~ ("[" ~ expression ~ "]")* ~ "=" ~ expression } // TODO: Is this optimal? Can the left side be written more elegantly?
expression_statement = {expression}

assignee_list = { type_name? ~ identifier ~ ("," ~ type_name? ~ identifier)*} // declarations or assignments

// Expressions
expression_list = {expression ~ ("," ~ expression)*}

expression = { term ~ (op_binary ~ term)* }
term = { ("(" ~ expression ~ ")") | conditional_expression | postfix_expression | primary_expression}

conditional_expression = { "if" ~ expression ~ "then" ~ expression ~ "else" ~ expression ~ "fi"}
postfix_expression = { primary_expression ~ ("[" ~ expression ~ "]" | "(" ~ expression_list? ~ ")")+ }
primary_expression = { identifier
                    | constant
                    | "(" ~ expression ~ ")"
                    | "[" ~ expression_list ~ "]" //special case for array initialization
                    }
// End Expressions

identifier = @{ ((!keyword ~ ASCII_ALPHA) | (keyword ~ (ASCII_ALPHANUMERIC | "_"))) ~ (ASCII_ALPHANUMERIC | "_")* }
constant = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }

op_inclusive_or = {"|"}
op_exclusive_or = {"^"}
op_and = {"&"}
op_equal = {"=="}
op_not_equal = {"!="}
op_lt = {"<"}
op_lte = {"<="}
op_gt = {">"}
op_gte = {">="}
op_add = {"+"}
op_sub = {"-"}
op_mul = {"*"}
op_div = {"/"}
op_pow = {"**"}
op_binary = _ { op_pow | op_inclusive_or | op_exclusive_or | op_and | op_equal | op_not_equal | op_lt | op_lte | op_gt | op_gte | op_add | op_sub | op_mul | op_div }

WHITESPACE = _{ " " | "\t" | "\\" ~ NEWLINE}
COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!NEWLINE ~ ANY)*) }

// TODO: Order by alphabet
keyword = @{"for" | "endfor" | "as" | "in" | "return" | "byte" | "field" |
            "const" | "if" | "do" | "else" | "export" | "false" |
            "def" | "for" | "import" | "uint" |
            "in" | "public" | "private" | "return" |
            "struct" | "true"
            }